## .题目描述
满足 N! 的末尾恰好有 K 个 0 的最小的 N 是多少? 

如果这样的 N 不存在输出 −1。

输入格式
一个整数 K。
输出格式
一个整数代表答案。 
样例输入
2
样例输出
10
提示
对于 30% 的数据，1 ≤ K ≤ 106 .

对于 100% 的数据，1 ≤ K ≤ 1018 .

## 解题思路
这是一道数学问题，可以分解质因数，因为末尾有0，所以必须含有10 = 2 * 5这个因子，由于2的个数远远多于5的个数，所以只需要考虑5的个数即可。可以发现，N!中5的个数就是答案（此处为伏笔）。

我们不妨假设对于一个特定的N值，它的阶乘结果记作 f(N) = 1 * 2 * 3 * ... * N。 已知任意正整数 N 和 K，我们可以通过计算 f(N) 能够被多少个因子 5 整除，从而判断是否满足条件。
根据题目的描述，当且仅当能够**恰好有 K 个 0**时才视为符合要求，也就是说我们要找到**最小的 N**使得 f(N) 能够恰好被 K 个因子 5 整除。

由于每个偶数都可以拆分成两个因子，而看到后面有多余的2会对解题想法产生影响，故需要特殊处理。
先来看几组样例数据：

K=1：5! =120（末尾1个0），6! =720（末尾1个0），7! =5040（末尾1个0），……

K=2：10! =3628800（末尾2个0），……
K=3: 15! =1307674368000(末尾3个0),......

可以发现，数字从1~10时，存在两组符合题意的结果，分别是5和10。因此，当K=1或K=2时，答案就是5(5*1)和10(5*2)。
但是数到 25! 阶乘，发现末尾连续的0并不是 25(5*5) 

```java
public class Main {
    public static void main(String[] args) {
        BigInteger ans = BigInteger.valueOf(2);
        for(int i = 3; i<=25;i++){
            ans = ans.multiply(BigInteger.valueOf(i));
        }
        System.out.println(ans.toString());
    }
}
```
```
15511210043330985984000000
```
末尾有6个连续的0，这是为什么？

因为在计算一个数字的阶乘时，其中有多少个因子5，取决于该数字中含有多少个5、10、15、20等数字。

比如5!，其中包含了一个5，所以5!末尾有1个0；而10!，其中包含了两个5，所以10!末尾有2个0。用数学语言表示，可以写成10! = 2 × 5!，其中2没有贡献因子5。

类似地，对于25!，其中包含了5、10、15、20、25这5个数字，共包含4个因子5和1个因子25。因此，25!末尾有 $4+2×1=6$ 个0（其中2是因子5的贡献，1是因子25的贡献）。

一个更好的方法是用数学公式来计算阶乘末尾有多少个连续的0。这个公式是：

末尾0的个数 = n/5 + n/25 + n/125 + …

这个公式的意思是，我们要先计算n里面有多少个5的倍数，然后再计算n里面有多少个25的倍数，然后再计算n里面有多少个125的倍数，以此类推，直到没有更大的5的幂次。每一个5的倍数都会贡献一个0，每一个25的倍数都会贡献两个0，每一个125的倍数都会贡献三个0，依此类推。我们把所有这些0加起来就得到了阶乘末尾0的个数。

例如，如果n是25，那么我们可以用这个公式来计算：

末尾0的个数 = 25/5 + 25/25 = 5 + 1 = 6

这个结果和用阶乘展开得到的结果一致。

如果n是100，那么我们可以用这个公式来计算：

末尾0的个数 = 100/5 + 100/25 + 100/125 = 20 + 4 + 0 = 24

所以我们要设立一个递归函数实现这个数学公式函数 f(N)，表示 N! 中有多少个因子 5。
这个函数可以用递归的方式定义，如下：

```
f(N) = 0, 如果 N < 5
f(N) = k + f(k), 如果 N >= 5，其中 k = N / 5（取整）
```

这个函数的意思是，如果 N 小于 5，那么 N! 中没有因子 5，所以返回 0。
如果 N 大于等于 5，那么 N! 中有 k = N / 5（取整）个因子 5，分别来自于 5, 10, …, k * 5 这些数。
但是这些数中还可能有更多的因子 5，比如 25 = 5 * 5，所以我们还要加上 f(k)，也就是 k! 中有多少个因子 5。

比如，如果 N = 10，那么 f(10) = k + f(k) = 2 + f(2) = 2 + 0 = 2。也就是说，10! 中有两个因子 5，分别来自于 5 和 10。
再比如，如果 N = 25，那么 f(25) = k + f(k) = 5 + f(5) = 6。也就是说，25! 中有六个因子 5，分别来自于 5,10,15,20,25 中的一个和25中的另一个。
单纯找到因子数还不够，我们还要满足**最小N!**这个条件
所以，我们要找到一个 N，使得 f(N) = K。这个 N 可以用二分查找的方法来寻找
其中右边界设置为 `k*5`，是因为我们需要找到满足条件的最小正整数N。
在计算阶乘时，因子2的个数比因子5的个数多得多，因此除了5、10、15、20等数字之外，每隔4个数字就会增加一个因子5。
因此，当因子5的个数为K时，N的值不会超过5K
```
令 l = 5, r = K * 5（一个上界）
当 l < r 时，重复以下步骤：
    计算 mid = l+(r-l) / 2（取整+避免溢出）
    计算 f(mid)
    如果 f(mid) < K，则令 l = mid + 1
    如果 f(mid) > K，则令 r = mid
    如果 f(mid) == K，则令 r = mid，并继续循环
最后，如果 l == r，并且 f(l) == K，则输出 l
否则，输出 -1
```

这个方法的意思是，我们从一个区间 [l, r] 开始寻找 N。
我们先计算区间的中点 mid 和它对应的 f(mid)，然后根据 f(mid) 和 K 的大小关系来缩小区间。
如果 f(mid) 小于 K，说明答案在右半区间；如果 f(mid) 大于 K，说明答案在左半区间；
如果 f(mid) 等于 K，说明答案可能是 mid 或者在左半区间。
我们不断重复这个过程，直到区间缩小为一个点或者不存在答案。
比如，如果 K = 2，那么我们可以得到以下的过程：
```
l = 5, r = 10
mid = (5 + 10) / 2 = 7
f(7) = 1 + f(1) = 1 < K
l = mid + 1 = 8

l = 8, r = 10
mid = 8+(10-8) / 2 = 9
f(9) = 1 + f(1) = 1 < K
l = mid + 1 = 10

l = 10, r = 10 
mid = 10+(10-10) / 2 = 10
f(10) = 2 + f(2) = 2 == K
r = mid

l == r，并且 f(l) == K，输出 l = 10
```

如果K=5，那么算法的过程是这样的：
```

l = 5, r = 25
mid = 5 + (25-5) / 2 = 15 
f(15) = 3 + f(3) = 3 < K 
l = 15 + 1 = 16

l = 16, r = 25 
mid = 16 + (25-16) / 2 = 20 
f(20) = 4 + f(4) = 4 < K 
l = mid + 1 = 21

l = 21, r = 25 
mid = 21 + (25-21) / 2 = 23
f(23) = 4 + f(4) = 4 < K 
l = mid + 1 = 24

l = 24, r = 25 
mid = 24 + (25-24) / 2 = 24
f(24) = 4 + f(4) = 4 < K 
l = mid + 1 = 25
```

此时，l >= r，搜索范围为空，说明没有找到满足条件的数，输出-1。


整个实现代码如下
```java

public class Main {
    public static void main(String[] args) {
        for(int i = 0;i < 1e18;i++){
            zeroNumber(i);
        }
    }

    // 计算 N! 中有多少个因子 5 的递归函数
    public static int countFactor5(int n) {
        if (n < 5) return 0;
        int k = n / 5;
        return k + countFactor5(k);
    }

    // 寻找满足 N! 的末尾恰好有 K 个 0 的最小的 N 的函数
    public static int zeroNumber(int k) {
        if (k == 0) return 1; // 特殊情况
        int l = 5, r = k * 5; // 设置左右边界

        // 在while循环中，我们需要设置边界条件为 l < r，只要左端点小于右端点，就一直进行查找。
        // 而最终找到的答案N必然会满足 l == r，因为此时区间只剩下一个数。
        while (l < r) {
            int mid = l+(r-l) / 2; // 计算中间值
            int f = countFactor5(mid); // 计算中间值的阶乘中有多少个因子 5
            if (f < k) { // 如果因子 5 的个数小于 K，则说明答案在右半区间
                l = mid + 1;
            } else { // 否则，在左半区间
                r = mid;
            }
        }


        if (l == r && countFactor5(l) == k) { // 如果找到了一个 N，使得 N! 的末尾恰好有 K 个 0
            // while循环的作用就是将找到的N逐步向下调整至能够被5整除的最小值，并将其作为函数的返回值。
            while (l % 5 != 0) { // 则找到最小的能被 5 整除的 N
                l--;
            }
            return l; // 返回答案
        } else { // 否则，不存在这样的 N
            return -1;
        }
    }
}
```

## 练习题
[有序矩阵中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/)
[组合](https://leetcode.cn/problems/combinations/)
[K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)



## 参考
[第十三届蓝桥杯JavaB组部分题解](https://zhuanlan.zhihu.com/p/495741612)